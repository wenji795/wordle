# web-mini-project

PGCert IT: Programming with Web Technologies Web Mini Project
Due: Friday 5th January 2024 at 17:00

This mini project requires you to develop a clone of the popular word game "wordle". There are eight tasks in this assignment to complete. Before starting the assignment, read through and gain an understanding of the requirements. Notes: ● The assignment is graded out of 60 marks and is worth 10% of your final Programming for Industry grade. ● After completing the assignment, you should have a single HTML file that includes an additional JavaScript and CSS file, which when opened in a browser provides a functional application. ● Each task within the assignment should have a clearly marked commit that can be checked out and tested by the marker. The marker will check out each of these labelled commits when marking your solution. If there is no labelled commit for a given task or if the program does not run correctly for the given task at that commit, a negative scaling factor will be applied to that task. ● When complete, ensure your source files and text are pushed to Gitlab. Ensure that your lecturer is able to access the project, by checking that it is correctly located in your lab exercises group. ● A git usage grade will be applied as a scaling factor to your achieved grade. Usage consisting of only a single commit will result in a maximum achievable grade of 50%, with more regular usage covering the spectrum up to 100%. Number of commits, along with evidence of usage throughout the development of your solution will play into the grade received. ● IMPORTANT: Read the instructions carefully before attempting each task.

Introduction Wordle is an online word deduction game that became popular in early 2022. The objective of the game is to guess a 5 letter word using feedback given with each guessed word. Feedback is given visually by indicating if letters in your guess are found within the target word, and if so, whether they are placed in the correct position or not. The goal of the game is to identify the target word within 6 guesses. At each stage of the game, the player is prompted to enter a valid word as a guess. Validity is determined by checking that the entered word is exactly 5 characters long, and that it represents a word that can be found in the dictionary. The game then responds with a visualisation of the guess that indicates which letters from your guess are not present in the target word, which letters are present but which are in the incorrect position, and which letters are present and also in the correct position. Examples of valid word guesses would be: ● CRATE ● DEPOT ● QUIET Examples of invalid word guesses would be: ● STICKS (6 characters) ● ARE (3 characters) ● FLOOB (Not present in dictionary) An example response to the guessed word "STEAK" against the target word "SCARE" would be the following, where a green highlight indicates a letter present in the target word that is positioned correctly, a yellow highlight indicates a letter present in the target word that is not positioned correctly, and grey indicating the letter is not present in the target word. S T E A K Using this feedback, the player can eliminate possible words and get closer to the solution. A complete example game for the target word "SCARE" is shown in Figure 1. 1
N I C K S C U S H Y S C R A M S C A R S S C A R F S C A R E Figure 1: Example classic wordle game 2

Requirements The goal of this assignment is to develop a 6-character version of the wordle game that a player can interact with using their keyboard or mouse through a web browser. Players will be presented with an interface showing a current guess area, a list of prior guesses with feedback, and an on-screen keyboard which can be used to enter guesses as an alternative to their keyboard. Unlike with classic wordle, players are not restricted to 1 game per day with a limited number of attempts, instead players can make as many guesses as needed, and can start a new game with a new target word as desired. For this assignment, you’ll complete a series of tasks as you work your way towards a fully functional implementation. As you complete each task, it might be a good idea to save a working version of the program at that point. The tasks do not have to be completed in order, you may choose to complete easier tasks ahead of more difficult ones. In addition to the design requirements, you are also required to demonstrate good usage of git. Ensure that you regularly commit your code, with accompanying descriptive commit messages. Further ensure that following the completion of each task you make a clearly labelled commit that indicates to the marker where you completed the task so that these commits can be used for marking. Unlike with previous projects you have been provided, this one has not been provided as a git repository. Before you begin you will need to create a repository on Gitlab for this project inside your lab-exercises group, and push the provided project to the newly created repository. To do this: ● Create a repository called web-mini-project inside your lab-exercises group on Gitlab ● Open IntelliJ and create a new blank web project ● Enable git support in the VCS > Enable version control integration menu ● Perform an initial commit ● Follow the instructions provided by Gitlab for adding existing code 3

Task One: Setup The structure of this project is intended to be relatively simple, using one each of HTML, CSS, and JavaScript files. To begin, you need to create initial files and ensure that these are connected correctly. Create your 3 initial files, and link the CSS and JavaScript files into the HTML file. Add some simple HTML content, then verify your CSS is linked correctly by applying some obvious styling. Further, add example code to your JavaScript file which will be executed once the page has loaded, and verify that this functions as expected. Note: While this seems like a simple step, resist the temptation to skip past the verification steps. Ensuring that the files are linked together at this stage will save a lot of possible frustration in the future! 4

Task Two: User Input Create an on-screen keyboard which can be used to interact with your future game. This should provide the letters A-Z, and should additionally provide "Backspace", "Enter", and "New Game" buttons. The arrangement of the A-Z letters should closely follow the QWERTY layout seen on computer keyboards, but the 3 additional keys can be placed as you wish. An example layout is shown in Figure 2. Style this on-screen keyboard such that it is horizontally centred on the page, and positioned at the bottom of the browser window regardless of the window size. Figure 2: Example on-screen keyboard layout Write appropriate JavaScript code that will detect when one of these buttons has been clicked, and prints the value of the key that was pressed to the browser console (i.e., when the "G" key is clicked, the function should produce the string "G"). For the 3 additional keys, produce "Backspace", "Enter", and "NewGame" values for the respective buttons. Extend this code so that typing keys on the computer keyboard behaves in the same way, with the Escape key acting as the "New Game" button. Keys other than A-Z, Enter, Backspace, and Escape should not produce any output. Modify the on-screen keyboard so that when a key is clicked there is a visual indication - such as changing the key border or background colour - so that it is obvious which key has been interacted with. Further, have this visual change occur when the physical keyboard key is pressed, i.e., when the physical "Y" key is pressed, the on-screen keyboard "Y" key should show a visual indication. Note: When working on the JavaScript side of this, you may find it beneficial to tackle it in small chunks rather than trying to do it all at once. Consider approaches such as printing a simple message or value when any button is pressed before working up to detecting the specific key. You may also choose to support physical keyboard input before on-screen keyboard input as this may be the easier of the two options. Once you have one of the options working, you can move on to the next tasks and return to complete this later. 5

Task Three: Target Word Your game needs to keep track of a 6 letter target word that the player will be attempting to guess over the course of the game. This needs to be determined before the player is allowed to make any guesses so that appropriate feedback can be given. Random words of a specified length which can be used as targets can be obtained through the (undocumented) https://words.trex-sandwich.com/ API endpoint. This endpoint takes two optional query parameters; count which indicates how many words are desired; and length which specifies the length of word that is required. A list of words meeting this criteria is returned as JSON. Update your game such that when the game loads, a 6 character target word is obtained using this service and stored in a variable accessible to your other JavaScript code. As it would not be possible to guess the word before it has been chosen, update your code so that the "Enter" button will not generate any output until the target word has been selected. Add a visual element to the on-screen keyboard "Enter" key that indicates that it is disabled, and remove this once the target word is selected. Note: It is useful to be able to validate that your code is working correctly here. Consider adding a browser console logging message that displays the target word once it is chosen so that you can verify it is working. Note: If you are struggling to think how to do this, consider setting a constant target word such as "TARGET" in the interim so that you can continue with later tasks. You can always return later to make this work properly. 6

Task Four: Current Guess Add an area to the top of your page that will show the current guess as it is being provided by the user. This should allow for a maximum of 6 characters to be shown, with placeholders present when fewer than 6 have been typed. An example layout showing what this may look like can be seen in Figure 3. The underlying HTML structure and appearance is up to you, however it is suggested that you reuse HTML & CSS that make up your on-screen keyboard here. Figure 3: Example current guess visualisation showing a partial guess Update your input handling code so that when a physical or on-screen keyboard A-Z key is pressed, the corresponding value appears in the next available spot in this area. If there are no more spots available (i.e., 6 letters have been provided), further A-Z key presses should not modify the input area. Further update your input handling code such that when the "Backspace" key is pressed on either the on-screen or physical keyboards, the last letter of the current guess is removed from the area, freeing up a slot for a new letter. If there are no slots in use (i.e., no letters have been provided), then further "Backspace" key presses should not modify the input area. When complete, you should be able to type input and have it appear in the current guess field, and erase typed letters with the "Backspace" key. Hint: Making use of a flexbox for laying out each letter "slot" will make accessing individual slots easier in JavaScript. The first slot will be the 0'th child of the flexbox, the second slot the 1'st child, the third the 2'nd child, etc. Hint: It is a good idea to think about how you are going to represent the application state at this stage. When you are providing a guess, how can you tell how many letters have been typed? How will you determine where the next typed letter goes? While it may be tempting to store this information in the HTML by updating the DOM, you will find it frustrating to interact with it from JavaScript. A better approach is to store the current guess as a variable in JavaScript, and update the HTML when this variable is changed to reflect the new state. 7

Task Five: Submitting Guesses When 6 letters have been provided as the current guess, the player should be able to submit that guess by pressing the "Enter" key on the on-screen or physical keyboard. To be accepted as a valid guess however, the guess has to be a word that could be the target word - it must be present in the dictionary and spelled correctly. Validation of words in this fashion can again be accomplished using the (again undocumented) https://words.trex-sandwich.com/your_word API endpoint. To use this endpoint, the final your_word path component can be replaced with the word you wish to check. A JSON object is returned indicating if the provided word is a valid word, or not. Update your code so that when fewer than 6 letters have been provided for the current guess, the on-screen keyboard "Enter" button is shown visually to be disabled, and when pressed does not produce output. When the current guess is exactly 6 letters long, the on-screen keyboard "Enter" button should be visually enabled, and when clicked should begin a guess submission process. This process should perform the following steps: ● Verify if the word is spelled correctly ● If the word is spelled incorrectly ○ Animate the current guess area so that it shakes from side to side a few times ○ Stop the process ● If the word is spelled correctly ○ Store the guess in a JavaScript variable ○ Print the guess to the browser console ○ Clear the current guess ○ Stop the process Note: The animation here is not critical, this can be left until a later time. Rather than creating an animation from scratch, consider looking at the source code of the "animate.css" library, which provides a collection of useful animations. Note: As with Task Three, if you are struggling with the word validation consider using a constant true/false value in code as a stand-in. This will give you a placeholder that you can come back to later to properly implement, but will allow you to continue on. Hint: Again, consider how you are representing your application state. We will be tracking 0 or more guesses over the course of the game, there should be a convenient way to store this in JavaScript. 8

Task Six: Guess Feedback Getting feedback on guesses is critical to the player's ability to eventually guess the target word. To give this feedback, guesses need to be displayed on the page with visual indications identifying correctly placed letters, incorrectly placed letters, and letters that are not present in the target word. Update your code so that submitted guesses appear on the page underneath the current guess area. As guesses are submitted, they should be stored in a JavaScript variable, then displayed on the page below any earlier guesses. These guess entries should appear visually similar to the current guess, but with the additional behaviour of having different background colours for each guess letter based on the condition of the letter. These conditions are: ● The letter is present in the target word, and the position of the letter in the guess and the target word is the same - background colour green. ● The letter is present in the target word, but the position of the letter is not the same in the guess and the target word - background colour orange. ● The letter is not present in the target word - background colour grey. Extend the background colouring behaviour to the on-screen keyboard. Keys for letters that have been used in guesses should update their colour to reflect their most recent usage condition - i.e., if letter "A" was present but incorrectly placed in guess 1, then the "A" key should be coloured orange. If the "A" was then correctly placed in guess 2, then the "A" key colour will update to be green. An example game showing this behaviour can be seen in Figure 4. Note the on-screen keyboard does not show any orange keys following the final guess, as all letters are now in the correct positions. 9

Figure 4: A completed game demonstrating highlighting of guess characters and on-screen keyboard keys as feedback. 10

Task Seven: New Game & Clean-up Update your code so that when the on-screen keyboard "New Game" button, or physical keyboard "Escape" key is pressed, the player is presented with a Yes/No message prompt that asks if they wish to start a new game. If the player selects "No", the message prompt should close and no further action should be taken. If they select "Yes", the game should be reset - removing all guesses and highlights - and a new target word should be chosen. Reloading the page is not sufficient to achieve this, it must be done programmatically. Modify your code so that if the game has ended because the player has correctly guessed the target word, the "New Game" prompt above should be displayed automatically. If the player responds "No", the prompt should close, but the page should reject all key inputs except for the "New Game" button. Task Eight: Maintaining State Your game should now be working correctly, but there is one outstanding issue - if you reload the page in the middle of a game, your progress is lost. Modify your game such that the game state is stored using the browser localStorage after each state change - recording the current guess, submitted guesses, and the target word. Further modify your code so that it checks the localStorage when loading the page, and if prior state is found it is restored rather than starting a new game. 11